<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BTfast: Parsing XML files/strings to an XMLNode structure and Rendering XMLNode&#39;s to files/string.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BTfast
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__conversions.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Parsing XML files/strings to an XMLNode structure and Rendering XMLNode's to files/string.<div class="ingroups"><a class="el" href="group___x_m_l_parser_general.html">The XML parser</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gacb95f4f00e4cf3756aac0e3a53765248"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_x_m_l_node.html">XMLNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__conversions.html#gacb95f4f00e4cf3756aac0e3a53765248">XMLNode::parseString</a> (XMLCSTR lpXMLString, XMLCSTR tag=NULL, <a class="el" href="struct_x_m_l_results.html">XMLResults</a> *pResults=NULL)</td></tr>
<tr class="memdesc:gacb95f4f00e4cf3756aac0e3a53765248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an <a class="el" href="struct_x_m_l.html">XML</a> string and return the root of a <a class="el" href="struct_x_m_l_node.html" title="Main Class representing a XML node.">XMLNode</a> tree representing the string.  <a href="group__conversions.html#gacb95f4f00e4cf3756aac0e3a53765248">More...</a><br /></td></tr>
<tr class="separator:gacb95f4f00e4cf3756aac0e3a53765248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e5968e052d58350918cd91e3535624b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_x_m_l_node.html">XMLNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__conversions.html#ga5e5968e052d58350918cd91e3535624b">XMLNode::parseFile</a> (XMLCSTR filename, XMLCSTR tag=NULL, <a class="el" href="struct_x_m_l_results.html">XMLResults</a> *pResults=NULL)</td></tr>
<tr class="memdesc:ga5e5968e052d58350918cd91e3535624b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an <a class="el" href="struct_x_m_l.html">XML</a> file and return the root of a <a class="el" href="struct_x_m_l_node.html" title="Main Class representing a XML node.">XMLNode</a> tree representing the file.  <a href="group__conversions.html#ga5e5968e052d58350918cd91e3535624b">More...</a><br /></td></tr>
<tr class="separator:ga5e5968e052d58350918cd91e3535624b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc044148e2b9b8264a320b7b6e398158"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_x_m_l_node.html">XMLNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__conversions.html#gacc044148e2b9b8264a320b7b6e398158">XMLNode::openFileHelper</a> (XMLCSTR filename, XMLCSTR tag=NULL)</td></tr>
<tr class="memdesc:gacc044148e2b9b8264a320b7b6e398158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an <a class="el" href="struct_x_m_l.html">XML</a> file and return the root of a <a class="el" href="struct_x_m_l_node.html" title="Main Class representing a XML node.">XMLNode</a> tree representing the file. A very crude error checking is made. An attempt to guess the Char Encoding used in the file is made.  <a href="group__conversions.html#gacc044148e2b9b8264a320b7b6e398158">More...</a><br /></td></tr>
<tr class="separator:gacc044148e2b9b8264a320b7b6e398158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4496629c7a268db5435946c7bdd4eb28"><td class="memItemLeft" align="right" valign="top"><a id="ga4496629c7a268db5435946c7bdd4eb28"></a>
static XMLCSTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__conversions.html#ga4496629c7a268db5435946c7bdd4eb28">XMLNode::getError</a> (XMLError error)</td></tr>
<tr class="memdesc:ga4496629c7a268db5435946c7bdd4eb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">this gives you a user-friendly explanation of the parsing error <br /></td></tr>
<tr class="separator:ga4496629c7a268db5435946c7bdd4eb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e19d3587f88f503ff1cfd98fcd13cb1"><td class="memItemLeft" align="right" valign="top">XMLSTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__conversions.html#ga9e19d3587f88f503ff1cfd98fcd13cb1">XMLNode::createXMLString</a> (int nFormat=1, int *pnSize=NULL) const</td></tr>
<tr class="memdesc:ga9e19d3587f88f503ff1cfd98fcd13cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_x_m_l.html">XML</a> string starting from the current <a class="el" href="struct_x_m_l_node.html" title="Main Class representing a XML node.">XMLNode</a>.  <a href="group__conversions.html#ga9e19d3587f88f503ff1cfd98fcd13cb1">More...</a><br /></td></tr>
<tr class="separator:ga9e19d3587f88f503ff1cfd98fcd13cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacef9de855bd31c6cda5482cb296f28ae"><td class="memItemLeft" align="right" valign="top">XMLError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__conversions.html#gacef9de855bd31c6cda5482cb296f28ae">XMLNode::writeToFile</a> (XMLCSTR filename, const char *encoding=NULL, char nFormat=1) const</td></tr>
<tr class="memdesc:gacef9de855bd31c6cda5482cb296f28ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the content of an xmlNode inside a file.  <a href="group__conversions.html#gacef9de855bd31c6cda5482cb296f28ae">More...</a><br /></td></tr>
<tr class="separator:gacef9de855bd31c6cda5482cb296f28ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fcc1637751a4788cfc5690b1c80842b"><td class="memItemLeft" align="right" valign="top">static char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__conversions.html#ga2fcc1637751a4788cfc5690b1c80842b">XMLNode::setGlobalOptions</a> (<a class="el" href="struct_x_m_l_node.html#a81bcd09f9c752b65633c1ca28ea025f2">XMLCharEncoding</a> characterEncoding=XMLNode::char_encoding_UTF8, char guessWideCharChars=1, char dropWhiteSpace=1, char removeCommentsInMiddleOfText=1)</td></tr>
<tr class="memdesc:ga2fcc1637751a4788cfc5690b1c80842b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the global options for the conversions.  <a href="group__conversions.html#ga2fcc1637751a4788cfc5690b1c80842b">More...</a><br /></td></tr>
<tr class="separator:ga2fcc1637751a4788cfc5690b1c80842b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7af7e3bab8d21722dd4f191a4aa7c1d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_x_m_l_node.html#a81bcd09f9c752b65633c1ca28ea025f2">XMLCharEncoding</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__conversions.html#gac7af7e3bab8d21722dd4f191a4aa7c1d">XMLNode::guessCharEncoding</a> (void *buffer, int bufLen, char useXMLEncodingAttribute=1)</td></tr>
<tr class="memdesc:gac7af7e3bab8d21722dd4f191a4aa7c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guess the character encoding of the string (ascii, utf8 or shift-JIS)  <a href="group__conversions.html#gac7af7e3bab8d21722dd4f191a4aa7c1d">More...</a><br /></td></tr>
<tr class="separator:gac7af7e3bab8d21722dd4f191a4aa7c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9e19d3587f88f503ff1cfd98fcd13cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e19d3587f88f503ff1cfd98fcd13cb1">&#9670;&nbsp;</a></span>createXMLString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLSTR XMLNode::createXMLString </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nFormat</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnSize</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="struct_x_m_l.html">XML</a> string starting from the current <a class="el" href="struct_x_m_l_node.html" title="Main Class representing a XML node.">XMLNode</a>. </p>
<p>The returned string should be free'd using the "freeXMLString" function.</p>
<p>If nFormat==0, no formatting is required otherwise this returns an user friendly <a class="el" href="struct_x_m_l.html">XML</a> string from a given element with appropriate white spaces and carriage returns. if pnSize is given it returns the size in character of the string. </p>

</div>
</div>
<a id="gac7af7e3bab8d21722dd4f191a4aa7c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7af7e3bab8d21722dd4f191a4aa7c1d">&#9670;&nbsp;</a></span>guessCharEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_m_l_node.html#a81bcd09f9c752b65633c1ca28ea025f2">XMLNode::XMLCharEncoding</a> XMLNode::guessCharEncoding </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>useXMLEncodingAttribute</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Guess the character encoding of the string (ascii, utf8 or shift-JIS) </p>
<p>The "guessCharEncoding" function try to guess the character encoding. You most-probably will never have to use this function. It then returns the appropriate value of the global parameter "characterEncoding" described in the <a class="el" href="group__conversions.html#ga2fcc1637751a4788cfc5690b1c80842b" title="Sets the global options for the conversions.">XMLNode::setGlobalOptions</a>. The guess is based on the content of a buffer of length "bufLen" bytes that contains the first bytes (minimum 25 bytes; 200 bytes is a good value) of the file to be parsed. The <a class="el" href="group__conversions.html#gacc044148e2b9b8264a320b7b6e398158" title="Parse an XML file and return the root of a XMLNode tree representing the file. A very crude error che...">XMLNode::openFileHelper</a> function is using this function to automatically compute the value of the "characterEncoding" global parameter. There are several heuristics used to do the guess. One of the heuristic is based on the "encoding" attribute. The original <a class="el" href="struct_x_m_l.html">XML</a> specifications forbids to use this attribute to do the guess but you can still use it if you set "useXMLEncodingAttribute" to 1 (this is the default behavior and the behavior of most parsers). If an inconsistency in the encoding is detected, then the return value is "0". </p>

</div>
</div>
<a id="gacc044148e2b9b8264a320b7b6e398158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc044148e2b9b8264a320b7b6e398158">&#9670;&nbsp;</a></span>openFileHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_m_l_node.html">XMLNode</a> XMLNode::openFileHelper </td>
          <td>(</td>
          <td class="paramtype">XMLCSTR&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XMLCSTR&#160;</td>
          <td class="paramname"><em>tag</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse an <a class="el" href="struct_x_m_l.html">XML</a> file and return the root of a <a class="el" href="struct_x_m_l_node.html" title="Main Class representing a XML node.">XMLNode</a> tree representing the file. A very crude error checking is made. An attempt to guess the Char Encoding used in the file is made. </p>
<p>The "openFileHelper" function reports to the screen all the warnings and errors that occurred during parsing of the <a class="el" href="struct_x_m_l.html">XML</a> file. This function also tries to guess char Encoding (UTF-8, ASCII or SHIT-JIS) based on the first 200 bytes of the file. Since each application has its own way to report and deal with errors, you should rather use the "parseFile" function to parse <a class="el" href="struct_x_m_l.html">XML</a> files and program yourself thereafter an "error reporting" tailored for your needs (instead of using the very crude "error reporting" mechanism included inside the "openFileHelper" function).</p>
<p>If the <a class="el" href="struct_x_m_l.html">XML</a> document is corrupted, the "openFileHelper" method will:</p><ul>
<li>display an error message on the console (or inside a messageBox for windows).</li>
<li>stop execution (exit).</li>
</ul>
<p>I strongly suggest that you write your own "openFileHelper" method tailored to your needs. If you still want to parse the file, you can use the APPROXIMATE_PARSING option as explained inside the note at the beginning of the "xmlParser.cpp" file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the path of the <a class="el" href="struct_x_m_l.html">XML</a> file to parse. </td></tr>
    <tr><td class="paramname">tag</td><td>the name of the first tag inside the <a class="el" href="struct_x_m_l.html">XML</a> file. If the tag parameter is omitted, this function returns a node that represents the head of the xml document including the declaration term (&lt;? ... ?&gt;). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5e5968e052d58350918cd91e3535624b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e5968e052d58350918cd91e3535624b">&#9670;&nbsp;</a></span>parseFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_m_l_node.html">XMLNode</a> XMLNode::parseFile </td>
          <td>(</td>
          <td class="paramtype">XMLCSTR&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XMLCSTR&#160;</td>
          <td class="paramname"><em>tag</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_m_l_results.html">XMLResults</a> *&#160;</td>
          <td class="paramname"><em>pResults</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse an <a class="el" href="struct_x_m_l.html">XML</a> file and return the root of a <a class="el" href="struct_x_m_l_node.html" title="Main Class representing a XML node.">XMLNode</a> tree representing the file. </p>
<p>The "parseFile" function parse an <a class="el" href="struct_x_m_l.html">XML</a> file and return the root of a <a class="el" href="struct_x_m_l_node.html" title="Main Class representing a XML node.">XMLNode</a> tree. The "opposite" of this function is the function "writeToFile" that re-creates an <a class="el" href="struct_x_m_l.html">XML</a> file from an <a class="el" href="struct_x_m_l_node.html" title="Main Class representing a XML node.">XMLNode</a> tree. If the <a class="el" href="struct_x_m_l.html">XML</a> document is corrupted, the "parseFile" method will initialize the "pResults" variable with some information that can be used to trace the error. If you still want to parse the file, you can use the APPROXIMATE_PARSING option as explained inside the note at the beginning of the "xmlParser.cpp" file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the path to the <a class="el" href="struct_x_m_l.html">XML</a> file to parse </td></tr>
    <tr><td class="paramname">tag</td><td>the name of the first tag inside the <a class="el" href="struct_x_m_l.html">XML</a> file. If the tag parameter is omitted, this function returns a node that represents the head of the xml document including the declaration term (&lt;? ... ?&gt;). </td></tr>
    <tr><td class="paramname">pResults</td><td>a pointer to a <a class="el" href="struct_x_m_l_results.html" title="Structure used to obtain error details if the parse fails.">XMLResults</a> variable that will contain some information that can be used to trace the <a class="el" href="struct_x_m_l.html">XML</a> parsing error. You can have a user-friendly explanation of the parsing error with the "getError" function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacb95f4f00e4cf3756aac0e3a53765248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb95f4f00e4cf3756aac0e3a53765248">&#9670;&nbsp;</a></span>parseString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_m_l_node.html">XMLNode</a> XMLNode::parseString </td>
          <td>(</td>
          <td class="paramtype">XMLCSTR&#160;</td>
          <td class="paramname"><em>lpXMLString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XMLCSTR&#160;</td>
          <td class="paramname"><em>tag</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_m_l_results.html">XMLResults</a> *&#160;</td>
          <td class="paramname"><em>pResults</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse an <a class="el" href="struct_x_m_l.html">XML</a> string and return the root of a <a class="el" href="struct_x_m_l_node.html" title="Main Class representing a XML node.">XMLNode</a> tree representing the string. </p>
<p>The "parseString" function parse an <a class="el" href="struct_x_m_l.html">XML</a> string and return the root of a <a class="el" href="struct_x_m_l_node.html" title="Main Class representing a XML node.">XMLNode</a> tree. The "opposite" of this function is the function "createXMLString" that re-creates an <a class="el" href="struct_x_m_l.html">XML</a> string from an <a class="el" href="struct_x_m_l_node.html" title="Main Class representing a XML node.">XMLNode</a> tree. If the <a class="el" href="struct_x_m_l.html">XML</a> document is corrupted, the "parseString" method will initialize the "pResults" variable with some information that can be used to trace the error. If you still want to parse the file, you can use the APPROXIMATE_PARSING option as explained inside the note at the beginning of the "xmlParser.cpp" file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lpXMLString</td><td>the <a class="el" href="struct_x_m_l.html">XML</a> string to parse </td></tr>
    <tr><td class="paramname">tag</td><td>the name of the first tag inside the <a class="el" href="struct_x_m_l.html">XML</a> file. If the tag parameter is omitted, this function returns a node that represents the head of the xml document including the declaration term (&lt;? ... ?&gt;). </td></tr>
    <tr><td class="paramname">pResults</td><td>a pointer to a <a class="el" href="struct_x_m_l_results.html" title="Structure used to obtain error details if the parse fails.">XMLResults</a> variable that will contain some information that can be used to trace the <a class="el" href="struct_x_m_l.html">XML</a> parsing error. You can have a user-friendly explanation of the parsing error with the "getError" function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2fcc1637751a4788cfc5690b1c80842b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fcc1637751a4788cfc5690b1c80842b">&#9670;&nbsp;</a></span>setGlobalOptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char XMLNode::setGlobalOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_l_node.html#a81bcd09f9c752b65633c1ca28ea025f2">XMLCharEncoding</a>&#160;</td>
          <td class="paramname"><em>characterEncoding</em> = <code>XMLNode::char_encoding_UTF8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>guessWideCharChars</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dropWhiteSpace</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>removeCommentsInMiddleOfText</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the global options for the conversions. </p>
<p>The "setGlobalOptions" function allows you to change four global parameters that affect string &amp; file parsing. First of all, you most-probably will never have to change these 3 global parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guessWideCharChars</td><td>If "guessWideCharChars"=1 and if this library is compiled in WideChar mode, then the <a class="el" href="group__conversions.html#ga5e5968e052d58350918cd91e3535624b" title="Parse an XML file and return the root of a XMLNode tree representing the file.">XMLNode::parseFile</a> and <a class="el" href="group__conversions.html#gacc044148e2b9b8264a320b7b6e398158" title="Parse an XML file and return the root of a XMLNode tree representing the file. A very crude error che...">XMLNode::openFileHelper</a> functions will test if the file contains ASCII characters. If this is the case, then the file will be loaded and converted in memory to WideChar before being parsed. If 0, no conversion will be performed.</td></tr>
    <tr><td class="paramname">guessWideCharChars</td><td>If "guessWideCharChars"=1 and if this library is compiled in ASCII/UTF8/char* mode, then the <a class="el" href="group__conversions.html#ga5e5968e052d58350918cd91e3535624b" title="Parse an XML file and return the root of a XMLNode tree representing the file.">XMLNode::parseFile</a> and <a class="el" href="group__conversions.html#gacc044148e2b9b8264a320b7b6e398158" title="Parse an XML file and return the root of a XMLNode tree representing the file. A very crude error che...">XMLNode::openFileHelper</a> functions will test if the file contains WideChar characters. If this is the case, then the file will be loaded and converted in memory to ASCII/UTF8/char* before being parsed. If 0, no conversion will be performed.</td></tr>
    <tr><td class="paramname">characterEncoding</td><td>This parameter is only meaningful when compiling in char* mode (multibyte character mode). In wchar_t* (wide char mode), this parameter is ignored. This parameter should be one of the three currently recognized encodings: XMLNode::encoding_UTF8, XMLNode::encoding_ascii, XMLNode::encoding_ShiftJIS.</td></tr>
    <tr><td class="paramname">dropWhiteSpace</td><td>In most situations, text fields containing only white spaces (and carriage returns) are useless. Even more, these "empty" text fields are annoying because they increase the complexity of the user's code for parsing. So, 99% of the time, it's better to drop the "empty" text fields. However The <a class="el" href="struct_x_m_l.html">XML</a> specification indicates that no white spaces should be lost when parsing the file. So to be perfectly XML-compliant, you should set dropWhiteSpace=0. A note of caution: if you set "dropWhiteSpace=0", the parser will be slower and your code will be more complex.</td></tr>
    <tr><td class="paramname">removeCommentsInMiddleOfText</td><td>To explain this parameter, let's consider this code: <div class="fragment"><div class="line"><a class="code" href="struct_x_m_l_node.html">XMLNode</a> x=<a class="code" href="group__conversions.html#gacb95f4f00e4cf3756aac0e3a53765248">XMLNode::parseString</a>(<span class="stringliteral">&quot;&lt;a&gt;foo&lt;!-- hello --&gt;bar&lt;!DOCTYPE world &gt;chu&lt;/a&gt;&quot;</span>,<span class="stringliteral">&quot;a&quot;</span>);</div>
</div><!-- fragment --> If removeCommentsInMiddleOfText=0, then we will have: <div class="fragment"><div class="line">x.<a class="code" href="group__navigate.html#gacfe86b318bec6ed981ec2ede1b82a01c">getText</a>(0) -&gt; <span class="stringliteral">&quot;foo&quot;</span></div>
<div class="line">x.<a class="code" href="group__navigate.html#gacfe86b318bec6ed981ec2ede1b82a01c">getText</a>(1) -&gt; <span class="stringliteral">&quot;bar&quot;</span></div>
<div class="line">x.<a class="code" href="group__navigate.html#gacfe86b318bec6ed981ec2ede1b82a01c">getText</a>(2) -&gt; <span class="stringliteral">&quot;chu&quot;</span></div>
<div class="line">x.<a class="code" href="group__navigate.html#gae1fcdd6a5e7c33b8c3c42ceb695a8a92">getClear</a>(0) --&gt; <span class="stringliteral">&quot;&lt;!-- hello --&gt;&quot;</span></div>
<div class="line">x.<a class="code" href="group__navigate.html#gae1fcdd6a5e7c33b8c3c42ceb695a8a92">getClear</a>(1) --&gt; <span class="stringliteral">&quot;&lt;!DOCTYPE world &gt;&quot;</span></div>
</div><!-- fragment --> If removeCommentsInMiddleOfText=1, then we will have: <div class="fragment"><div class="line">x.<a class="code" href="group__navigate.html#gacfe86b318bec6ed981ec2ede1b82a01c">getText</a>(0) -&gt; <span class="stringliteral">&quot;foobar&quot;</span></div>
<div class="line">x.<a class="code" href="group__navigate.html#gacfe86b318bec6ed981ec2ede1b82a01c">getText</a>(1) -&gt; <span class="stringliteral">&quot;chu&quot;</span></div>
<div class="line">x.<a class="code" href="group__navigate.html#gae1fcdd6a5e7c33b8c3c42ceb695a8a92">getClear</a>(0) --&gt; <span class="stringliteral">&quot;&lt;!DOCTYPE world &gt;&quot;</span></div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>"0" when there are no errors. If you try to set an unrecognized encoding then the return value will be "1" to signal an error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Sometime, it's useful to set "guessWideCharChars=0" to disable any conversion because the test to detect the file-type (ASCII/UTF8/char* or WideChar) may fail (rarely). </dd></dl>

</div>
</div>
<a id="gacef9de855bd31c6cda5482cb296f28ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacef9de855bd31c6cda5482cb296f28ae">&#9670;&nbsp;</a></span>writeToFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLError XMLNode::writeToFile </td>
          <td>(</td>
          <td class="paramtype">XMLCSTR&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>encoding</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>nFormat</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the content of an xmlNode inside a file. </p>
<p>If nFormat==0, no formatting is required otherwise this returns an user friendly <a class="el" href="struct_x_m_l.html">XML</a> string from a given element with appropriate white spaces and carriage returns. If the global parameter "characterEncoding==encoding_UTF8", then the "encoding" parameter is ignored and always set to "utf-8". If the global parameter "characterEncoding==encoding_ShiftJIS", then the "encoding" parameter is ignored and always set to "SHIFT-JIS". If "_XMLWIDECHAR=1", then the "encoding" parameter is ignored and always set to "utf-16". If no "encoding" parameter is given the "ISO-8859-1" encoding is used. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="agroup__navigate_html_gacfe86b318bec6ed981ec2ede1b82a01c"><div class="ttname"><a href="group__navigate.html#gacfe86b318bec6ed981ec2ede1b82a01c">XMLNode::getText</a></div><div class="ttdeci">XMLCSTR getText(int i=0) const</div><div class="ttdoc">return ith text field</div><div class="ttdef"><b>Definition:</b> xmlParser.cpp:2686</div></div>
<div class="ttc" id="agroup__conversions_html_gacb95f4f00e4cf3756aac0e3a53765248"><div class="ttname"><a href="group__conversions.html#gacb95f4f00e4cf3756aac0e3a53765248">XMLNode::parseString</a></div><div class="ttdeci">static XMLNode parseString(XMLCSTR lpXMLString, XMLCSTR tag=NULL, XMLResults *pResults=NULL)</div><div class="ttdoc">Parse an XML string and return the root of a XMLNode tree representing the string.</div><div class="ttdef"><b>Definition:</b> xmlParser.cpp:1783</div></div>
<div class="ttc" id="astruct_x_m_l_node_html"><div class="ttname"><a href="struct_x_m_l_node.html">XMLNode</a></div><div class="ttdoc">Main Class representing a XML node.</div><div class="ttdef"><b>Definition:</b> xmlParser.h:227</div></div>
<div class="ttc" id="agroup__navigate_html_gae1fcdd6a5e7c33b8c3c42ceb695a8a92"><div class="ttname"><a href="group__navigate.html#gae1fcdd6a5e7c33b8c3c42ceb695a8a92">XMLNode::getClear</a></div><div class="ttdeci">XMLClear getClear(int i=0) const</div><div class="ttdoc">return ith clear field (comments)</div><div class="ttdef"><b>Definition:</b> xmlParser.cpp:2682</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.16 </li>
  </ul>
</div>
</body>
</html>
